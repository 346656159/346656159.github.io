<!DOCTYPE html>
<head>
    <title>如何为 ThinkJS 3 网站优化 TTFB 时间</title>
    <link rel="stylesheet" href="/css/nav.css">
    <link rel="stylesheet" href="/css/aside.css">
    <link rel="stylesheet" href="/css/footer.css">
    <style>
        pre{white-space: pre-line;}
        article{font-size: 1.5em;}
        article h1,article p,article pre{margin:35px;}
    </style>

    <script src="/js/nav.js"></script>
</head>
<html>
    <body>
        <div class="container">
            <main>
                <article>
                    <h1>如何为 ThinkJS 3 网站优化 TTFB 时间</h1>
                    <pre>
                            今年早些时候，奇舞团开源的 Node.js 框架 ── ThinkJS 迎来了她的 3.0 版本。尽管今年我很少更新博客，但「每次 ThinkJS 发布大版本，我都要更新博客程序」的老传统还是不能丢。所以，你现在看到的这个博客，已经是基于 ThinkJS 3 全面重构后的新版。

                            ThinkJS 3 基于 Koa 2.x 开发，内核实现得非常小巧，框架通过 Middleware（兼容 Koa）、Adapter、Extend 等机制来扩展出强大而丰富的功能。按照惯例，ThinkJS 大版本之间无法平滑进行，但这次升级带来的工作量不算太大，本站的升级工作花了一下午全部完成。
                            
                            基于 ThinkJS 开发的网站普遍都很快，这篇文章我打算聊聊如何为 ThinkJS 3 网站优化 TTFB 时间，使之变得更快。
                            
                            Time to first byte（简称 TTFB）时间，又称首字节时间，是 WEB 性能优化中非常重要的指标。它代表着从浏览器发起 HTTP 请求到收到 HTTP 响应第一个字节的这段时间，包含了 DNS 解析、建立 TCP 连接、建立 SSL 连接、发送 HTTP 请求、网络传输、服务端处理、30X 重定向等阶段。在影响 TTFB 所有因素中，服务端程序何时输出响应决定了服务端处理时间的长短，也是本文关注的优化目标。
                            
                            优化 WEB 页面的 TTFB 时间除了要尽可能优化业务逻辑之外，还有两个常用技巧：
                            
                            多个 HTTP 请求响应（动静拆分）；
                            一个 HTTP 请求多次响应（分块传输）；
                            前者无非就是先尽快输出一个无服务端复杂逻辑的空壳页面，再发起 ajax、jsonp 等异步请求填充内容。这种方案不利于 SEO，比较适用于单页应用。
                            
                            像本站这种以内容为主的 Web 页面，非常适合采用第二个技巧来优化 TTFB 时间。本文重点介绍它。
                            
                            分块传输响应需要用到我之前介绍过的 HTTP Transfer-Encoding: chunked 机制。有了这个机制，服务端可以随时将已经完成的部分响应发送给给客户端，而不必等待全部完成后再一次发送。浏览器拿到部分响应，就能解析并执行其中的 HTML、CSS 和 JS 代码，还能加载其中引用的子资源，最终让用户更快看到部分页面内容。分块传输也是 Facebook 在 2009 年实现的 Bigpipe 方案的理论基础，这里不再赘述。
                            
                            再来说说 ThinkJS。
                            
                            在 ThinkJS 之前几个版本中，我们可以通过 http.write(content) 发送多个 chunk，再通过 http.end(content) 发送最后一个 chunk，非常方便。
                            
                            而 ThinkJS 3 使用的 Koa 2.x，只能通过 ctx.body 设置并结束响应，意味着通常情况下响应只能发送一次，还得放在整个 Controller 流程的最后。
                            
                            通过分析代码，我找到在 ThinkJS 3 中多次发送响应的两种方案：
                            
                            ctx.body 支持传入 Stream，创建 Readable 流 rs 并多次调用 rs.push(content) 可以多次发送 chunk，调用 rs.push(null) 可以结束响应；
                            Koa 代码层面上并没有禁止我们使用 ctx.res，通过 res 对象可以完全控制响应；
                            方案一比较正统；方案二则危险得多，官方都说要后果自负：
                    </pre>
                </article>
            </main>
        </div>
        <div style="clear: both;"></div>




        <script src="/js/aside.js"></script>
        <script src="/js/footer.js"></script>
    </body>
</html>